Okay, here is a comprehensive specification document based on our discussion, designed to be handed off to a developer.

Project Specification: Flashcard Application with Spaced Repetition, Extension, and Gesture Input

Version: 1.0
Date: October 26, 2023

1. Introduction & Overview

This document outlines the specifications for a web-based flashcard application designed to help users learn and memorize information using a spaced repetition system (SRS) based on the Leitner method. The project consists of three main components:

A core logic library (TypeScript).

A web application (Node.js/Express backend with PostgreSQL database, and a standard web frontend).

A browser extension (for Google Chrome) to facilitate adding cards from Google Search results.

A key feature is the use of hand gesture recognition via webcam for providing feedback during practice sessions. The system assumes a single user for this initial version (no multi-user accounts or authentication).

2. Core Logic Library/Module (TypeScript)

This module contains the fundamental algorithms for managing flashcards and the spaced repetition schedule. It should be implemented in TypeScript.

2.1. Core Types

/**
 * Represents a flashcard with a front and back. Immutable.
 */
export class Flashcard {
  public readonly id: string; // Unique identifier (e.g., UUID generated by backend/DB)
  public readonly front: string;
  public readonly back: string;
  public readonly hint: string; // Original "weak" hint provided at creation
  public readonly tags: ReadonlyArray<string>;

  // Constructor updated to include ID
  constructor(
    id: string,
    front: string,
    back: string,
    hint: string,
    tags: ReadonlyArray<string>
  ) {
    this.id = id;
    this.front = front;
    this.back = back;
    this.hint = hint;
    this.tags = tags;
  }
}

/**
 * Represents the user's answer difficulty for a practice trial.
 */
export enum AnswerDifficulty {
  Wrong = 0,
  Hard = 1,
  Easy = 2,
}

/**
 * Represents the learning buckets as a Map.
 * Keys are bucket numbers (non-negative integers).
 * Values are Sets of Flashcards in that bucket.
 */
export type BucketMap = Map<number, Set<Flashcard>>;

/**
 * Represents a single practice history record.
 */
export type PracticeRecord = {
  date: Date;
  card: Flashcard; // Or cardId: string, depending on context
  difficulty: AnswerDifficulty;
};

/**
 * Represents the full answer history.
 */
export type History = Array<PracticeRecord>;

/**
 * Structure for progress statistics result.
 */
export type ComputeProgressResult = {
  totalCards: number;
  cardsByBucket: Map<number, number>; // Key: bucket number, Value: count
  historyStats: {
    totalPractices: number;
    difficultyCounts: {
      wrong: number;
      hard: number;
      easy: number;
    };
  };
  message?: string; // Optional message for empty inputs
};


(Note: The Flashcard class requires a unique id. The core logic functions might operate on Flashcard objects fetched from the backend/database which include this id.)

2.2. Core Functions

toBucketSets(bucketMap: BucketMap): Array<Set<Flashcard>>

Input: BucketMap.

Output: Array<Set<Flashcard>>.

Behavior:

Validate that all keys in bucketMap are non-negative integers. Throw an Error if invalid keys are found.

Determine the highest bucket number (maxBucket) present as a key.

Create an output array of size maxBucket + 1.

For each index i from 0 to maxBucket:

If bucketMap contains key i, set outputArray[i] = bucketMap.get(i).

If bucketMap does not contain key i, set outputArray[i] = new Set<Flashcard>().

If bucketMap is empty, return [].

getBucketRange(buckets: Array<Set<Flashcard>>): { minBucket: number, maxBucket: number } | undefined

Input: Array<Set<Flashcard>>.

Output: Object with minBucket, maxBucket numbers, or undefined.

Behavior:

If buckets array is empty or all Sets within it are empty, return undefined.

Find the smallest index i where buckets[i] is not empty (minBucket).

Find the largest index j where buckets[j] is not empty (maxBucket).

Return { minBucket: minBucket, maxBucket: maxBucket }.

practice(buckets: Array<Set<Flashcard>>, day: number): Set<Flashcard>

Input: Array<Set<Flashcard>>, day (non-negative integer).

Output: Set<Flashcard> containing cards to practice.

Behavior:

Validate day. Throw an Error if negative or not an integer.

Initialize practiceSet = new Set<Flashcard>().

If day === 0: If buckets[0] exists, add all its cards to practiceSet.

If day > 0: Iterate through buckets with index n. If buckets[n] exists and day % (2**n) === 0, add all cards from buckets[n] to practiceSet.

Return practiceSet.
(Note: The backend API will use a date-based logic instead of this day number, see Section 4.1)

update(buckets: BucketMap, card: Flashcard, difficulty: AnswerDifficulty): BucketMap

Input: BucketMap, Flashcard, AnswerDifficulty.

Output: A new BucketMap reflecting the update (immutable operation).

Behavior:

Find the currentBucket number containing the card. Iterate through the map's sets. If not found, throw Error("Flashcard not found in any bucket").

Determine newBucket:

Wrong: newBucket = 0.

Hard: newBucket = Math.max(0, currentBucket - 1).

Easy: newBucket = currentBucket + 1.

Create a deep copy of the input buckets map (newBuckets).

Create a copy of the set at currentBucket in newBuckets. Remove card from this copied set. Update newBuckets with the modified set (consider removing the key if the set becomes empty).

Get the set for newBucket from newBuckets (create if non-existent). Create a copy of this set. Add card to the copied set. Update newBuckets with this modified set.

Return newBuckets.

getHint(card: Flashcard, lettersToReveal: number): string

Input: Flashcard, lettersToReveal (non-negative integer representing hint level/clicks).

Output: Hint string.

Behavior:

Validate lettersToReveal. Throw Error if negative or not an integer.

Initialize hintString = "", wordLetterIndex = 0.

Iterate through each character char of card.back:

If char is space: Append space to hintString, reset wordLetterIndex = 0.

If char is not space: Increment wordLetterIndex. If wordLetterIndex <= lettersToReveal, append char to hintString. Else, append _.

Return hintString.

computeProgress(buckets: BucketMap, history: History): ComputeProgressResult

Input: BucketMap, History array.

Output: ComputeProgressResult object.

Behavior:

Initialize result object with zero counts, empty maps/arrays.

Process buckets: Calculate totalCards and cardsByBucket map (bucketNum -> count).

Process history: Calculate totalPractices and difficultyCounts (wrong, hard, easy).

Set optional message based on whether buckets or history were effectively empty.

Return result.

3. System Architecture

Overall: Monolithic web application (backend + frontend) served together, plus a separate browser extension. Communication primarily via REST API.

Backend:

Language/Platform: Node.js

Framework: Express

Language: TypeScript

Database: PostgreSQL

Responsibilities: API implementation, database interaction, core logic execution.

Frontend:

Technology: Standard HTML, CSS, TypeScript/JavaScript. (A modern framework like React, Vue, or Angular is recommended but not strictly specified).

Responsibilities: User interface for practice, manual card creation, interaction with backend API, webcam access and gesture processing.

Gesture Library: MediaPipe Hand Landmarker (recommended).

Browser Extension:

Technology: Standard Extension APIs (HTML, CSS, JavaScript/TypeScript).

Target Browser: Google Chrome (initially).

Responsibilities: Detect text selection on Google Search, inject button, open web app URL on click.

Database Schema (PostgreSQL):

CREATE TABLE flashcards (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- Or SERIAL PRIMARY KEY
    front TEXT NOT NULL,
    back TEXT NOT NULL,
    hint TEXT, -- Optional weak hint
    tags TEXT[], -- Array of text tags
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE card_buckets (
    card_id UUID PRIMARY KEY, -- Each card is in exactly one bucket
    bucket_number INTEGER NOT NULL CHECK (bucket_number >= 0),
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    last_practiced_at TIMESTAMPTZ, -- Null if never practiced
    FOREIGN KEY (card_id) REFERENCES flashcards(id) ON DELETE CASCADE
);
-- Index for finding cards by bucket
CREATE INDEX idx_card_buckets_bucket_number ON card_buckets(bucket_number);
-- Index for finding practice cards based on last practiced time
CREATE INDEX idx_card_buckets_last_practiced ON card_buckets(last_practiced_at);


CREATE TABLE practice_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- Or SERIAL PRIMARY KEY
    card_id UUID NOT NULL,
    practice_date TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    difficulty INTEGER NOT NULL, -- 0=Wrong, 1=Hard, 2=Easy
    previous_bucket INTEGER, -- Bucket before this practice
    new_bucket INTEGER NOT NULL, -- Bucket after this practice
    FOREIGN KEY (card_id) REFERENCES flashcards(id) ON DELETE CASCADE
);
-- Index for fetching history by card
CREATE INDEX idx_practice_history_card_id ON practice_history(card_id);
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
SQL
IGNORE_WHEN_COPYING_END

(Note: Need to ensure updated_at and last_practiced_at in card_buckets are maintained correctly by the backend logic, possibly via triggers or application logic.)

4. Backend API Specification (Node.js/Express)

Base URL: /api

4.1. Get Practice Cards

Endpoint: GET /api/practice

Description: Retrieves flashcards due for practice today.

Request Body: None

Backend Logic:

Query card_buckets table joined with flashcards.

For each card in bucket n with last_practiced_at date L:

Calculate the review interval: interval = 2^n days.

Calculate the due date: dueDate = L + interval.

A card is due if:

It's in bucket 0 and last_practiced_at is NULL.

CURRENT_DATE >= dueDate.

Return the full details of all due Flashcard objects.

Success Response:

Status: 200 OK

Body: Array<Flashcard> (including id, front, back, hint, tags). Returns [] if none are due.

Error Response:

Status: 500 Internal Server Error

Body: { "message": "Error retrieving practice cards." }

4.2. Update Card After Practice

Endpoint: POST /api/practice/results

Description: Records a practice trial result and updates the card's bucket.

Request Body:

{
  "cardId": "string", // ID of the practiced card
  "difficulty": 0 | 1 | 2 // AnswerDifficulty enum value
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END

Backend Logic:

Validate input (cardId, difficulty).

Find the card and its currentBucket from card_buckets. If not found, return 404.

Determine newBucket based on difficulty and currentBucket (Wrong -> 0, Hard -> max(0, current-1), Easy -> current+1).

Record the trial in practice_history (store card_id, difficulty, currentBucket as previous_bucket, newBucket).

Update the card_buckets record for cardId: set bucket_number = newBucket, update last_practiced_at = CURRENT_TIMESTAMP, update updated_at.

Execute history insertion and bucket update within a database transaction for atomicity.

Success Response:

Status: 200 OK

Body: { "newBucketNumber": number }

Error Responses:

Status: 400 Bad Request (Invalid input) -> Body: { "message": "Invalid input: cardId and difficulty required." }

Status: 404 Not Found (Card ID doesn't exist) -> Body: { "message": "Card not found." }

Status: 500 Internal Server Error (DB error) -> Body: { "message": "Error updating practice results." }

4.3. Create New Flashcard

Endpoint: POST /api/cards

Description: Adds a new flashcard to the system, placing it in bucket 0.

Request Body:

{
  "front": "string", // Required
  "back": "string",  // Required
  "hint": "string", // Optional
  "tags": ["string"] // Optional
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END

Backend Logic:

Validate input (require front, back). Default hint to empty string and tags to empty array if omitted.

Insert a new record into flashcards table. Get the generated id.

Insert a new record into card_buckets with card_id = new ID, bucket_number = 0, last_practiced_at = NULL.

Execute both insertions within a database transaction.

Return the newly created flashcard object.

Success Response:

Status: 201 Created

Body: The created Flashcard object (including the new id).

{
  "id": "generated-unique-id",
  "front": "...",
  "back": "...",
  "hint": "...",
  "tags": [...]
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END

Error Responses:

Status: 400 Bad Request (Missing front or back) -> Body: { "message": "Missing required fields: front and back." }

Status: 500 Internal Server Error (DB error) -> Body: { "message": "Error creating flashcard." }

5. Frontend Application Specification

Technology: HTML, CSS, TypeScript/JavaScript. Use of a framework (React, Vue, Angular) is recommended for managing state and UI components.

Core Features:

Practice Mode:

Fetch due cards using GET /api/practice.

Display one card at a time (front side).

Provide a "Show Answer" button.

On reveal, display the back side.

Activate gesture recognition (or show fallback buttons).

On receiving feedback (gesture/button):

Send result using POST /api/practice/results.

Move to the next card or end session.

Hint Feature: During practice (before or after revealing answer), provide a "Hint" button. Each click increments a counter (lettersToReveal) and calls the getHint logic (implemented client-side or via a potential future API endpoint) to display the progressively revealed hint based on the card's back text.

Manual Card Creation:

Provide a dedicated page/view (e.g., accessible via navigation).

Include a form with inputs for front (required), back (required), hint (optional), tags (optional, perhaps comma-separated input or tag component).

On submit, send data using POST /api/cards. Provide user feedback (success/error).

Add Card Route for Extension:

Implement routing to handle a specific path, e.g., /add.

On this route, check for a URL query parameter named description.

If present, decode its value and pre-populate the front input field of the manual card creation form.

Gesture Recognition:

Library: Use MediaPipe Hand Landmarker (recommended).

Workflow:

Request webcam permission when practice mode starts (or first time needed). Handle denial gracefully (fall back to buttons).

After "Show Answer" is clicked, start processing webcam feed via MediaPipe. Display feed subtly for user positioning.

Implement logic to interpret hand landmarks to recognize:

Thumbs Up -> AnswerDifficulty.Easy (2)

Thumb Horizontal -> AnswerDifficulty.Hard (1)

Thumbs Down -> AnswerDifficulty.Wrong (0)

Require gesture hold for a short duration (e.g., 0.5s) for confirmation. Provide visual feedback of detected gesture.

Once confirmed, trigger POST /api/practice/results and stop gesture processing for that card.

Fallback: Always provide clickable buttons ("Wrong", "Hard", "Easy") as an alternative to gestures, especially if webcam access is denied or gesture recognition fails.

6. Browser Extension Specification

Target Browser: Google Chrome.

Permissions: activeTab, scripting (to inject content script and button), potentially storage (if configuration needed later).

Functionality:

Trigger: Runs a content script on pages matching https://www.google.com/search*.

Detection: Listens for the user finishing a text selection (mouseup event) within the search results area.

UI Injection: When text is selected, inject a small, non-intrusive button (e.g., floating near the selection) with text like "Add to Flashcards".

Action:

On button click, get the selected text (selectedDescription).

URL-encode selectedDescription.

Construct the target URL: [URL_of_your_web_app]/add?description=[encoded_description]. The base URL needs to be configurable or known.

Use chrome.tabs.create({ url: targetUrl }) or similar API to open the web application's "add" page in a new tab (or potentially find and update an existing tab).

Notes: The extension does not need to parse the Google search query itself according to the revised flow.

7. Error Handling Strategy

Core Library: Functions should throw specific Error objects for invalid inputs or unmet preconditions.

Backend API: Use standard HTTP status codes (2xx for success, 4xx for client errors like bad input or not found, 5xx for server errors). Return JSON bodies with a message field describing the error for 4xx/5xx responses. Implement proper error handling middleware in Express. Use database transactions to ensure atomicity for operations involving multiple table updates.

Frontend: Handle API errors gracefully. Display user-friendly messages (e.g., "Failed to save card", "Could not load practice cards"). Provide clear feedback on form validation errors. Handle webcam permission denial and gesture recognition failures by enabling fallback mechanisms (buttons).

Extension: Use console.error for logging issues. Handle potential errors during DOM manipulation or communication.

8. Testing Plan

Unit Tests (Core Library):

Use a JavaScript/TypeScript testing framework (e.g., Jest, Vitest).

Test each core function (toBucketSets, getBucketRange, practice, update, getHint, computeProgress).

Cover valid inputs, edge cases (empty maps/arrays, zero values, single items, missing bucket numbers), and invalid inputs (ensure errors are thrown as specified).

Verify immutability for the update function.

Integration Tests (Backend):

Test API endpoints interacting with a test database.

Verify:

POST /api/cards creates records correctly in flashcards and card_buckets.

GET /api/practice returns correct cards based on last_practiced_at and bucket number logic.

POST /api/practice/results updates card_buckets and creates practice_history records correctly within a transaction.

Error responses (4xx, 5xx) are returned appropriately.

Frontend Tests:

Component tests for UI elements (card display, forms).

Integration tests for frontend logic interacting with mock API calls.

E2E tests (using tools like Cypress or Playwright) simulating user flows:

Manually adding a card.

Completing a practice session using fallback buttons.

(Optional/Difficult) Mocking webcam input for testing gesture recognition flow if possible, otherwise manual testing is crucial here.

Extension Testing:

Manual testing on live google.com/search pages with various selections.

Verify button injection and correct URL opening.

Gesture Recognition Testing:

Extensive manual testing is required.

Test with different users, hand sizes, lighting conditions, backgrounds, and camera angles.

Verify correct mapping of gestures to difficulties.

Test responsiveness and confirmation logic.

9. Future Considerations / Assumptions

Authentication/Users: This specification assumes a single-user context. No user accounts, login, or data isolation between users is included. All data in the database belongs implicitly to the single "user" of the application instance. Adding multi-user support would be a significant future enhancement.

Deployment: Infrastructure and deployment details (hosting, database provisioning, domain) are not covered.

UI/UX Design: Specific visual design, layout details, and user experience refinements are not detailed. Wireframes or mockups would be beneficial.

Scalability: Assumes moderate usage. High concurrency or very large datasets might require database optimization or architectural changes.

Error Logging/Monitoring: Production deployment should include more robust server-side logging and potentially error monitoring services.

This specification should provide a solid foundation for a developer to begin implementation. Please review it carefully, and let me know if any clarifications or modifications are needed.